---
title: "Project Report"
author: "Zachary Katz, Tucker Morgan, Hun Lee, Jimmy Kelliher, and Tanvir Khan"
date: "12/11/2021"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---

```{r defaults, echo = FALSE, message = FALSE, warning = FALSE}
# load necessary packages
library(tidyverse)
library(patchwork)
library(reshape2)
library(rstatix)
library(patchwork)
library(ggridges)
library(spatstat)
library(ggpubr)
library(GGally)
library(readxl)
library(spatstat)

# set knitr defaults
knitr::opts_chunk$set(
    echo      = TRUE
  , message   = FALSE
  , fig.width = 6
  , fig.asp   = .6
  , out.width = "90%"
)

# set theme defaults
theme_set(
  theme_bw() +
  theme(
    legend.position = "bottom"
    , plot.title    = element_text(hjust = 0.5)
    , plot.subtitle = element_text(hjust = 0.5)    
    , plot.caption  = element_text(hjust = 0.0)
  )
)

# set color scale defaults
options(
    ggplot2.continuous.colour = "viridis"
  , ggplot2.continuous.fill   = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete   = scale_fill_viridis_d
```

## Motivation

It’s difficult to overstate the extent to which the COVID-19 pandemic has tested the world’s public health infrastructure over the past two years. At the same time, the COVID-19 “experience” has manifested unequally -- not just country to country, but even city to city. As one of the most heterogeneous urban areas in the world, New York City provides a fascinating case study into the ways in which socioeconomic status may be associated with, or even mediate, disparities in health outcomes. (For instance, it’s already well-documented that income and race, along with socioeconomic privilege and political ideology, drive inequities in COVID vaccination rate across US cities.)  

Knowing that socioeconomic factors have historically been associated with health outcomes, we aim to examine relationships between a range of predictors (e.g. race/ethnicity, education, broadband internet access, household income / occupational income score, public vs. private health insurance) and COVID-19 health outcomes -- namely, hospitalizations, deaths, and vaccinations.

## Related Work

In 2020, the COVID-19 pandemic was only one factor that increased the public attention on structural inequality. A confluence of recent events, from the Black Lives Matter movement to the election of New York City’s second Black mayor, has attracted the gaze of local researchers given the vast demographic and socioeconomic diversity concentrated in just one urban area. Our work is motivated by pre-existing analyses related to potential socioeconomic predictors and COVID-19 outcomes. For example, Little et al.’s research suggests an “unequal socioeconomic gradient in the demographic and clinical presentation of COVID-19 patients,” building on other analysis into census tract-level associations with key outcomes like hospitalization. As COVID-19’s endemicity becomes all but inevitable, with globalization expected to contribute to a rise in the number of pandemics easily spread across borders and continents, a comprehensive understanding of the predictors of hospitalization, death, and vaccination rates for COVID-19 may aid the development of effective intervention strategies that limit disparate impact across all disease stages.

While a number of studies have examined differential outcomes across neighborhoods in New York City (and have even, at times, attempted to approach causal explanations, such as subway utilization), no ecological study to-date has explored the potential for a ~20-variable  set of predictors to explain between-neighborhood variation across multiple COVID outcomes, including vaccination. Although prior work has explored disparities in testing and positivity, for example – and systemic meta-analyses have demonstrated disparities in COVID-19 outcomes by race, ethnicity, and socioeconomic status – our study takes a modeling-forward approach to generate a multivariate regression model that explains outcomes at the PUMA, or census-tract, level. We also contribute a novel method of predictive risk scoring to highlight the possibility of a given PUMA failing to achieve a key outcome target – in this case, 70% vaccination rate. Although further work will be required to better understand the mechanisms by which various contributing factors are associated with key outcomes, this research highlights the diversity of outcomes across a relatively small geographic area, and thus the potential for greater health equity in the future.

## Initial Questions

Our initial questions are centered on how demographic factors in New York City trend with COVID-19 outcomes. Particularly, what are the effects of predictors such as race/ethnicity or education on COVID-19 hospitalizations or vaccinations? Are there differences in COVID-19 hospitalizations or vaccinations when considering public vs. private health insurance? And are there differences in COVID-19 outcomes based on household income? Our aim is to examine the relationships between these predictors and outcomes in specified geographic areas across New York City.

## Data Sources and Cleaning

### Data Sources

#### Integrated Public Use Microdata Series (IPUMS USA)

The Integrated Public Use Microdata Series (IPUMS USA) consists of individual-level data from samples of the US population drawn from the American Community Surveys (ACS) of 2000 - present as well as from fifteen federal censuses from 1850 to 2010. Each record in IPUMS is a person with numerically coded characteristics and “weight” variables indicating how many persons in the population are represented by each record. Samples were created at different times by different investigators, which lead to a variety of documentation conventions. However, IPUMS applies consistent coding and documentation across records to allow for effective analysis over time. A data extraction system exists to allow users to pull particular samples and variables from IPUMS. This project uses demographic and macroeconomic data from the American Community Survey (ACS) 2019 five-year estimate via IPUMS.

While data from IPUMS is recorded at the individual-level, each interview is coded to a particular Public Use Microdata Area (PUMA) geography where the housing unit was located at the time of interview.

#### New York City Department of Health and Mental Hygiene (NYC DOHMH)

The New York City Department of Health and Mental Hygiene (NYC DOHMH) is one of the oldest public health agencies in the United States. Among other responsibilities, the DOHMH monitors the spread of infectious disease in NYC. The Department of Health classified the beginning of the COVID-19 pandemic as February 29, 2020, the date of the first laboratory-confirmed case. Since then, the DOHMH has recorded and reported COVID-19 data on a daily, weekly, or monthly basis. These data include cases, hospitalizations, and deaths by borough, modified Zip Code tabulation area (ZCTA), and demographic factors. As NYC has administered vaccinations for COVID-19, these data have been recorded and made available by borough, ZCTA, and demography. This project uses COVID-19 hospitalization rates, death rates, and vaccination rates by ZCTA in NYC.

#### Baruch College, City University of New York - Geoportal 

The Baruch Geoportal, maintained by the Newman Library at Baruch College, is a repository of geospatial resources including tabular data sets, tutorials, maps, and crosswalks. This project uses a crosswalk data set from Baruch Geoportal to apportion NYC ZCTAs to PUMAs, which allows PUMA-coded data from IPUMS to be analyzed alongside COVID-19 outcome data from DOHMH.

### Data Cleaning

#### Pulling Data

As mentioned above, monthly outcome data were obtained from the NYC DOHMH with data reported at the ZCTA-level geography. First, these data were summed over the time interval March 2020 - ### to obtain one cumulative incidence measure per ZCTA. However, the predictor variables from IPUMS were coded to the PUMA-level geography. The first step in the cleaning process was to convert these data into a common geography to facilitate further analysis. The Baruch ZCTA-PUMA crosswalk data set was used in this data conversion. Below is a brief excerpt:

```{r}
# Read in ZCTA/PUMA crosswalk
read_csv("./data/zcta_puma_cross.csv") %>% 
  head() %>% 
  knitr::kable()
```

The following  columns were used to convert ZCTA-level outcome data to PUMA-level data:

* ‘zcta10’ - ZCTA unique identifier

* ‘puma10’ - PUMA unique identifier

* ‘per_in_puma’ - percentage of the specified ZCTA that is located within the specified PUMA

* ‘per_of_puma’ - percentage of the specified PUMA that is occupied by the specified ZCTA

The following shows the mathematical expression used to convert from ZCTA-level outcome data to PUMA-level outcome data:

$$
\sum_{i = 1}^{n} \text{zcta_outcome_data}_{i} \cdot \text{per_in_puma}_{i} \cdot \text{per_of_puma}_{i} = \text{puma_outcome_data}
$$

This resulted in one cumulative incidence measure per PUMA (per 100,000 people for hospitalizations and deaths, a percentage for vaccinations).

The demographic dataset from IPUMS originally contained over 350,000 interviews from the NYC area, each coded to a PUMA and given a ‘perwt’ - person weight and ‘hhwt’- household weight. First, predictor variables were renamed and recoded according to the data dictionary (link to data dictionary) such that the following predictor variables were obtained for each interview along with ‘borough’ and ‘puma’ coding:

* ‘rent’: monthly rent (numeric)
* ‘household_income’: annual household income (numeric)
* ‘on_foodstamps’: whether a person is on food stamps (binary)
* ‘has_broadband’: whether a person has broadband internet (binary)
* ‘family_size’: number of individuals in family, including this individual (numeric)
* ‘num_children’: number of children in family (numeric)
* ‘sex’: sex of individual (binary)
* ‘age’: age of individual (numeric)
* ‘race’: race of individual (categorical factor)
* ‘birthplace’: whether this person was born in US or elsewhere (categorical factor)
* ‘US_citizen’: whether this person is a US citizen (categorical factor)
* ‘language’: primary language spoken at home (categorical factor)
* ‘education’: highest level of education obtained (categorical factor)
* ‘employment’: current employment status (categorical factor)
* ‘health_insurance’: type of insurance (public or private), if any (categorical factor)
* ‘personal_income’: annual personal income (numeric)
* ‘on_welfare’: whether person is on welfare (binary)
* ‘poverty_threshold’: whether the person is above or below the poverty line (binary)
* ‘work_transport’: most commonly used method of transportation to work (categorical factor)

```{r create cleaned interview level data set}
# Cleaning
jimzip <- function(csv_file, path) {
  # create full path to csv file
  full_csv <- paste0(path, "/", csv_file)
  # append ".zip" to csv file
  zip_file <- paste0(full_csv, ".zip")
  # unzip file
  unzip(zip_file)
  # read csv
  data_extract <- read_csv(csv_file)
  # be sure to remove file once unzipped (it will live in working directory)
  on.exit(file.remove(csv_file))
  # output data
  data_extract
}

# Apply function to filtered census data CSV
census_data <- jimzip("census_filtered.csv", "./data")

# Merging the Outcome Data

# Read in PUMA outcomes data
health_data <-
  read_csv("./data/outcome_puma.csv")

# Merge census data with PUMA outcomes data
merged_data <- merge(census_data, health_data, by = "puma")

# Deprecate census data alone
rm(census_data)

## Cleaning the Data

# Clean the merged census and outcomes data
# Each row represents one 
cleaned_data = 
  merged_data %>% 
  # Remove variables less useful for analysis or redundant (high probability of collinearity with remaining variables)
  select(-serial, -cluster, -strata, -multyear, -ancestr1, -ancestr2, -labforce, -occ, -ind, -incwage, -occscore, -pwpuma00, -ftotinc, -hcovpub) %>% 
  # Remove duplicate rows, if any
  distinct() %>% 
  # Rename variables
  rename(
    borough = countyfip,
    has_broadband = cihispeed,
    birthplace = bpl,
    education = educd,
    employment = empstat,
    personal_income = inctot,
    work_transport = tranwork,
    household_income = hhincome,
    on_foodstamps = foodstmp,
    family_size = famsize,
    num_children = nchild,
    US_citizen = citizen,
    puma_vacc_rate = puma_vacc_per,
    on_welfare = incwelfr,
    poverty_threshold = poverty
  ) %>% 
  # Recode variables according to data dictionary
  mutate(
    # Researched mapping for county
    borough = recode(
      borough,
      "5" = "Bronx",
      "47" = "Brooklyn",
      "61" = "Manhattan",
      "81" = "Queens",
      "85" = "Staten Island"
    ),
    rent = ifelse(
      rent == 9999, 0,
      rent
    ),
    household_income = ifelse(
      household_income %in% c(9999998,9999999), NA,
      household_income
    ),
    on_foodstamps = recode(
      on_foodstamps,
      "1" = "No",
      "2" = "Yes"
    ),
    has_broadband = case_when(
      has_broadband == "20" ~ "No",
      has_broadband != "20" ~ "Yes"
    ),
    sex = recode(
      sex,
      "1" = "Male",
      "2" = "Female"
    ),
    # Collapse Hispanic observation into race observation
    race = case_when(
      race == "1" ~ "White",
      race == "2" ~ "Black",
      race == "3" ~ "American Indian",
      race %in% c(4,5,6) ~ "Asian and Pacific Islander",
      race == 7 & hispan %in% c(1,2,3,4) ~ "Hispanic",
      race == 7 & hispan %in% c(0,9) ~ "Other",
      race %in% c(8,9) ~ "2+ races"
    ),
    birthplace = case_when(
      birthplace %in% 1:120 ~"US",
      birthplace %in% 121:950 ~ "Non-US",
      birthplace == 999 ~"Unknown"
    ),
    US_citizen = case_when(
      US_citizen %in% c(1,2) ~ "Yes",
      US_citizen %in% 3:8 ~"No",
      US_citizen %in% c(0,9) ~ "Unknown"
    ),
    # Chose languages based on highest frequency observed
    language = case_when(
      language == "1" ~ "English",
      language == "12" ~ "Spanish",
      language == "43" ~ "Chinese",
      language == "0" ~ "Unknown",
      language == "31" ~ "Hindi",
      !language %in% c(1,12,43,0,31) ~ "Other"
    ),
    # Collapse multiple health insurance variables into single variable
    health_insurance = case_when(
      hcovany == 1 ~ "None",
      hcovany == 2 && hcovpriv == 2 ~ "Private",
      hcovany == 2 && hcovpriv == 1 ~ "Public"
    ),
    education = case_when(
      education %in% 2:61 ~ "Less Than HS Graduate",
      education %in% 62:64 ~ "HS Graduate",
      education %in% 65:100 ~ "Some College",
      education %in% 110:113 ~ "Some College",
      education == 101 ~ "Bachelor's Degree",
      education %in% 114:116 ~ "Post-Graduate Degree",
      education %in% c(0,1,999) ~ "Unknown"
    ),
    employment = case_when(
      employment %in% c(0,3) ~ "Not in labor force",
      employment == 1 ~ "Employed",
      employment == 2 ~ "Unemployed"
    ),
    personal_income = ifelse(
      personal_income %in% c(9999998,9999999), NA,
      personal_income
    ),
    household_income = ifelse(
      household_income %in% c(9999998,9999999), NA,
      household_income
    ),
    on_welfare = case_when(
      on_welfare > 0 ~ "Yes",
      on_welfare == 0 ~ "No"
    ), 
    poverty_threshold = case_when(
      poverty_threshold >= 100 ~ "Above",
      poverty_threshold < 100 ~ "Below"
    ),
    work_transport = case_when(
      work_transport %in% c(31:37, 39) ~ "Public Transit",
      work_transport %in% c(10:20, 38) ~ "Private Vehicle",
      work_transport == 50 ~ "Bicycle",
      work_transport == 60 ~ "Walking",
      work_transport == 80 ~ "Worked From Home",
      work_transport %in% c(0, 70) ~ "Other"
    )
  ) %>% 
  # Eliminate columns no longer needed after transformation
  select(-hispan, -hcovany, -hcovpriv) %>% 
  # Relocate new columns
  relocate(health_insurance, .before = personal_income) %>% 
  relocate(poverty_threshold, .before = work_transport) %>% 
  relocate(on_welfare, .before = poverty_threshold) %>% 
  relocate(perwt, .before = hhwt) %>% 
  # Create factor variables where applicable
  mutate(across(.cols = c(puma, borough, on_foodstamps, has_broadband, sex, race, birthplace, US_citizen, language, health_insurance, education, employment, on_welfare, poverty_threshold, work_transport), as.factor)) %>% 
  # Ensure consistent use of percentages
  mutate(
    puma_death_rate = puma_death_rate / 100,
    puma_hosp_rate = puma_hosp_rate / 100
  )

# View first few rows
cleaned_data %>% 
  head() %>% 
  knitr::kable()
```

After cleaning variable names the 350,000+ interviews were summarized to the PUMA-level based on ‘perwt’ and ‘hhwt’. For each interview, the ‘perwt’ value describes the number of persons in the coded geographic area (PUMA) for which the interview is representative. For example, a ‘perwt’ of 34 indicates that there are 34 persons in the PUMA that share the same characteristics as described in the interview data (e.g., similar income, race, family size, etc.). The same is true of the ‘hhwt’ value for households in the coded PUMA. Therefore, the ‘perwt’ and ‘hhwt’ of each interview can be used to aggregate interview-level data to PUMA-level data as follows:

```{r cleaned PUMA level data set}
# Example data frame with weightings for summary stats over each PUMA
nyc_puma_summary = cleaned_data %>% 
  # Note: do we need to filter to one individual per household for household weightings?
  group_by(puma) %>%
  summarize(
    total_people = sum(perwt),
    median_household_income = weighted.median(household_income, hhwt, na.rm = TRUE),
    perc_foodstamps = sum(hhwt[on_foodstamps == "Yes"]) * 100 / sum(hhwt),
    perc_broadband = sum(hhwt[has_broadband == "Yes"]) * 100 / sum(hhwt),
    perc_male = sum(perwt[sex == "Male"]) * 100 / sum(perwt),
    median_age = weighted.median(age, perwt, na.rm = TRUE),
    perc_white = sum(perwt[race == "White"]) * 100 / sum(perwt),
    perc_foreign_born = sum(perwt[birthplace == "Non-US"]) * 100 / sum(perwt),
    perc_citizen = sum(perwt[US_citizen == "Yes"]) * 100 / sum(perwt),
    perc_english = sum(perwt[language == "English"]) * 100 / sum(perwt),
    perc_college = sum(perwt[education %in% c("Some College", "Bachelor's Degree", "Post-Graduate Degree")]) * 100 / sum(perwt),
    perc_unemployed = sum(perwt[employment == "Unemployed"]) * 100 / sum(perwt),
    perc_insured = sum(perwt[health_insurance %in% c("Private", "Public")]) * 100 / sum(perwt),
    median_personal_income = weighted.median(personal_income, perwt, na.rm = TRUE),
    perc_welfare = sum(perwt[on_welfare == "Yes"]) * 100 / sum(perwt),
    perc_poverty = sum(perwt[poverty_threshold == "Below"]) * 100 / sum(perwt),
    perc_public_transit = sum(perwt[work_transport == "Public Transit"]) * 100 / sum(perwt),
    covid_hosp_rate = median(puma_hosp_rate),
    covid_vax_rate = median(puma_vacc_rate),
    covid_death_rate = median(puma_death_rate)
  )

# View first few rows of PUMA-summarized data frame
nyc_puma_summary %>% head() %>% knitr::kable()
```

This cleaned and aggregated data set has 55 rows, one for each PUMA, and is the basis of the exploratory analysis that follows.

## Exploratory Analysis

```{r data set prep, echo = FALSE, message = FALSE, warning = FALSE}
# Data sets

# Interview level data
interview_level_data = cleaned_data %>% 
    mutate(
      above_hosp_median = as.factor(ifelse(puma_hosp_rate > median(puma_hosp_rate), 1, 0)),
      above_death_median = as.factor(ifelse(puma_death_rate > median(puma_death_rate), 1, 0)),
      above_vax_median = as.factor(ifelse(puma_vacc_rate > median(puma_vacc_rate), 1, 0)),
      age_class = as.factor(cut(age, breaks = c(0, 15, 30, 45, 60, 75, 90, 105), include.lowest = TRUE)),
      household_income_class = as.factor(cut(household_income, breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000), include.lowest = TRUE))
    ) %>% 
    mutate(age_class = fct_recode(age_class, 
                              "<16" = "[0,15]", 
                              "16-30" = "(15,30]", 
                              "31-45" = "(30,45]", 
                              "46-60" = "(45,60]", 
                              "61-75" = "(60,75]", 
                              "76-90" = "(75,90]", 
                              "91-105" = "(90,105]"),
           household_income_class = fct_recode(household_income_class, 
                                           "<$50k" = "[0,5e+04]", 
                                           "+$50k-100k" = "(5e+04,1e+05]", 
                                           "+$100k-150k" = "(1e+05,1.5e+05]", 
                                           "+$150k-200k" = "(1.5e+05,2e+05]", 
                                           "+$200k-250k" = "(2e+05,2.5e+05]", 
                                           "+$250k-300k" = "(2.5e+05,3e+05]", 
                                           "+$300k-350k" = "(3e+05,3.5e+05]",
                                           ">$350k" = "(3.5e+05,4e+05]"))

# PUMA level data with boroughs and some new metrics / categoricals
puma_level_data = 
  nyc_puma_summary %>% 
  # Add boroughs
  mutate(
    borough = as.factor(case_when(
      str_detect(puma, "37") ~ "Bronx",
      str_detect(puma, "38") ~ "Manhattan",
      str_detect(puma, "39") ~ "Staten Island",
      str_detect(puma, "40") ~ "Brooklyn",
      str_detect(puma, "41") ~ "Queens")
    )
  ) %>% 
  # Add ratio of deaths to hospitalizations
  mutate(
    covid_ratio = covid_death_rate / covid_hosp_rate
  ) %>% 
  # Add indicators for when PUMA's outcome rate is above or below median outcome rate across PUMAs
  mutate(
    above_hosp_median = as.factor(ifelse(covid_hosp_rate > median(covid_hosp_rate), 1, 0)),
    above_death_median = as.factor(ifelse(covid_death_rate > median(covid_death_rate), 1, 0)),
    above_vax_median = as.factor(ifelse(covid_vax_rate > median(covid_vax_rate), 1, 0)),
    above_ratio_median = as.factor(ifelse(covid_ratio > median(covid_ratio), 1, 0))
  ) %>% 
  # Turn hospitalization and death data into percentages
  mutate(
    covid_hosp_rate = covid_hosp_rate / 100,
    covid_death_rate = covid_death_rate / 100
  )

# Generate data frame with outcomes for each combination of sex, age (class), and race
race_age_sex = interview_level_data %>% 
  mutate(
    weighted_hosp = puma_hosp_rate * perwt / 100,
    weighted_death = puma_death_rate * perwt / 100,
    weighted_vax = puma_vacc_rate * perwt / 100,
    age_class = cut(age, breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100), include.lowest = TRUE)
  ) %>% 
  mutate(age_class = fct_recode(age_class, 
                                "<11" = "[0,10]", 
                                "11-20" = "(10,20]", 
                                "21-30" = "(20,30]", 
                                "31-40" = "(30,40]", 
                                "41-50" = "(40,50]", 
                                "51-60" = "(50,60]", 
                                "61-70" = "(60,70]",
                                "71-80" = "(70,80]",
                                "81-90" = "(80,90]",
                                "91-100" = "(90,100]")) %>% 
  group_by(race, age_class, sex) %>% 
  summarize(
    total_hosp = sum(weighted_hosp),
    total_vax = sum(weighted_vax),
    total_death = sum(weighted_death),
    people = sum(perwt),
    hosp_rate = total_hosp * 100 / people,
    vax_rate = total_vax * 100 / people,
    death_rate = total_death * 100 / people
  ) %>% 
  pivot_longer(
    cols = hosp_rate:death_rate,
    names_to = "outcome",
    values_to = "outcome_rate"
  )

# Pivot on outcomes data
# Each row represents one unique PUMA-outcome pairing
PUMA_outcomes = puma_level_data %>% 
  pivot_longer(
    cols = starts_with("covid"),
    values_to = 'outcome_rate'
  )

```

```{r exploratory functions, echo = FALSE, message = FALSE, warning = FALSE}
# Functions

# Turn lower half of pairwise matrix scatters into correlation (r) statistic
# Sourced from http://www.sthda.com/english/wiki/scatter-plot-matrices-r-base-graphs
panel.cor <- function(x, y){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- round(cor(x, y), digits=2)
    txt <- paste0("R = ", r)
    text(0.5, 0.5, txt)
}

# Reorder function for correlation matrix
# Sourced from http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization
reorder_cormat <- function(cormat){
  # Use correlation between variables as distance
  dd = as.dist((1-cormat)/2)
  hc = hclust(dd)
  cormat = cormat[hc$order, hc$order]
}

# Function to group and summarize interview-level data across two predictors
# Predictors can be categorical or continuous
two_var_summarize = function(predict1, predict2){
  
  if(is.factor(pull(interview_level_data, {{predict1}})) && is.factor(pull(interview_level_data, {{predict2}})) == TRUE) {
    
    a = interview_level_data %>% 
      mutate(
        weighted_vax = perwt * puma_vacc_rate,
        weighted_hosp = perwt * puma_hosp_rate,
        weighted_death = perwt * puma_death_rate,
        predict1 = {{predict1}},
        predict2 = {{predict2}}
        ) %>% 
      group_by(predict1, predict2) %>% 
      summarize(
        vax_rate = sum(weighted_vax) / sum(perwt),
        hosp_rate = sum(weighted_hosp) / sum(perwt),
        death_rate = sum(weighted_death) / sum(perwt),
        people = sum(perwt),
        num_vaxxed = sum(weighted_vax) / 100,
        num_hosp = sum(weighted_hosp) / 100,
        num_dead = sum(weighted_death) / 100
      )
    
    return(a)
    
  }
  
  if(is.factor(pull(interview_level_data, {{predict1}})) == FALSE | is.factor(pull(interview_level_data, {{predict2}})) == FALSE) {
    
    if(is.factor(pull(interview_level_data, {{predict1}})) == FALSE && is.factor(pull(interview_level_data, {{predict2}})) == TRUE) {
      
      a = interview_level_data %>% 
        mutate(
          weighted_vax = perwt * puma_vacc_rate,
          weighted_hosp = perwt * puma_hosp_rate,
          weighted_death = perwt * puma_death_rate,
          predict1 = cut({{predict1}}, breaks = 6, include.lowest = TRUE),
          predict2 = {{predict2}}
          ) %>% 
        group_by(predict1, predict2) %>% 
        summarize(
          vax_rate = sum(weighted_vax) / sum(perwt),
          hosp_rate = sum(weighted_hosp) / sum(perwt),
          death_rate = sum(weighted_death) / sum(perwt),
          people = sum(perwt),
          num_vaxxed = sum(weighted_vax) / 100,
          num_hosp = sum(weighted_hosp) / 100,
          num_dead = sum(weighted_death) / 100
        )
      
      return(a)
      
    }
    
    if(is.factor(pull(interview_level_data, {{predict1}})) == TRUE && is.factor(pull(interview_level_data, {{predict2}})) == FALSE) {
      
      a = interview_level_data %>% 
        mutate(
          weighted_vax = perwt * puma_vacc_rate,
          weighted_hosp = perwt * puma_hosp_rate,
          weighted_death = perwt * puma_death_rate,
          predict2 = cut({{predict2}}, breaks = 6, include.lowest = TRUE),
          predict1 = {{predict1}}
          ) %>% 
        group_by(predict1, predict2) %>% 
        summarize(
          vax_rate = sum(weighted_vax) / sum(perwt),
          hosp_rate = sum(weighted_hosp) / sum(perwt),
          death_rate = sum(weighted_death) / sum(perwt),
          people = sum(perwt),
          num_vaxxed = sum(weighted_vax) / 100,
          num_hosp = sum(weighted_hosp) / 100,
          num_dead = sum(weighted_death) / 100
        )
      
      return(a)
      
    }
    
    if(is.factor(pull(interview_level_data, {{predict1}})) == FALSE && is.factor(pull(interview_level_data, {{predict2}})) == FALSE) {
      
      a = interview_level_data %>% 
        mutate(
          weighted_vax = perwt * puma_vacc_rate,
          weighted_hosp = perwt * puma_hosp_rate,
          weighted_death = perwt * puma_death_rate,
          predict1 = cut({{predict1}}, breaks = 6, include.lowest = TRUE),
          predict2 = cut({{predict2}}, breaks = 6, include.lowest = TRUE)
          ) %>% 
        group_by(predict1, predict2) %>% 
        summarize(
          vax_rate = sum(weighted_vax) / sum(perwt),
          hosp_rate = sum(weighted_hosp) / sum(perwt),
          death_rate = sum(weighted_death) / sum(perwt),
          people = sum(perwt),
          num_vaxxed = sum(weighted_vax) / 100,
          num_hosp = sum(weighted_hosp) / 100,
          num_dead = sum(weighted_death) / 100
        )
      
      return(a)
    }
  }
}

# Function to disaggregate outcomes by input predictor variables across all census interviews
one_var_summarize = function(predict){
  
  if(is.factor(pull(interview_level_data, {{predict}})) == TRUE) {
    
    a = interview_level_data %>% 
      mutate(
        weighted_vax = perwt * puma_vacc_rate,
        weighted_hosp = perwt * puma_hosp_rate,
        weighted_death = perwt * puma_death_rate,
        predict = {{predict}}
        ) %>% 
      group_by(predict) %>% 
      summarize(
        vax_rate = sum(weighted_vax) / sum(perwt),
        hosp_rate = sum(weighted_hosp) / sum(perwt),
        death_rate = sum(weighted_death) / sum(perwt),
        people = sum(perwt),
        num_vaxxed = sum(weighted_vax) / 100,
        num_hosp = sum(weighted_hosp) / 100,
        num_dead = sum(weighted_death) / 100
      ) %>% 
      drop_na(predict)
    
    return(a)
    
  } else {
    
    a = interview_level_data %>% 
        mutate(
          weighted_vax = perwt * puma_vacc_rate,
          weighted_hosp = perwt * puma_hosp_rate,
          weighted_death = perwt * puma_death_rate,
          predict = cut({{predict}}, breaks = 6, include.lowest = TRUE)
          ) %>% 
        group_by(predict) %>% 
        summarize(
          vax_rate = sum(weighted_vax) / sum(perwt),
          hosp_rate = sum(weighted_hosp) / sum(perwt),
          death_rate = sum(weighted_death) / sum(perwt),
          people = sum(perwt),
          num_vaxxed = sum(weighted_vax) / 100,
          num_hosp = sum(weighted_hosp) / 100,
          num_dead = sum(weighted_death) / 100
        ) %>% 
      drop_na(predict)
      
      return(a)
    
  }
}

# Function to disaggregate outcomes by input predictor variables at the borough level
one_var_borough_summarize = function(predict){
  
  if(is.factor(pull(interview_level_data, {{predict}})) == TRUE) {
    
    a = interview_level_data %>% 
      mutate(
        weighted_vax = perwt * puma_vacc_rate,
        weighted_hosp = perwt * puma_hosp_rate,
        weighted_death = perwt * puma_death_rate,
        predict = {{predict}}
        ) %>% 
      group_by(predict, borough) %>% 
      summarize(
        vax_rate = sum(weighted_vax) / sum(perwt),
        hosp_rate = sum(weighted_hosp) / sum(perwt),
        death_rate = sum(weighted_death) / sum(perwt),
        num_people = sum(perwt),
        num_hosp = sum(weighted_hosp) / 100,
        num_vax = sum(weighted_vax) / 100,
        num_death = sum(weighted_death) / 100
      ) %>% 
      drop_na(predict)
    
    return(a)
    
  } else {
    
    a = interview_level_data %>% 
      mutate(
        predict = cut({{predict}}, breaks = 6, include.lowest = TRUE)
      ) %>% 
      mutate(
        weighted_vax = perwt * puma_vacc_rate,
        weighted_hosp = perwt * puma_hosp_rate,
        weighted_death = perwt * puma_death_rate
        ) %>% 
      group_by(predict, borough) %>% 
      summarize(
        vax_rate = sum(weighted_vax) / sum(perwt),
        hosp_rate = sum(weighted_hosp) / sum(perwt),
        death_rate = sum(weighted_death) / sum(perwt),
        num_people = sum(perwt),
        num_hosp = sum(weighted_hosp) / 100,
        num_vax = sum(weighted_vax) / 100,
        num_death = sum(weighted_death) / 100
      )
    
    return(a)
    
  }
}

# Function to generate a heatmap grid for a given outcome across PUMAs, split by any two variables
heatmap_two_var = function(predict1, predict2, outcome) {
  
  b = two_var_summarize({{predict1}}, {{predict2}})
  
  if(outcome == "vax") { 
    
    b %>% 
      ggplot(
        aes(
          x = predict1,
          y = predict2,
          fill = vax_rate
        )
      ) + 
      geom_tile()
  } else if(outcome == "hosp"){
    b %>% 
      ggplot(
        aes(
          x = predict1,
          y = predict2,
          fill = hosp_rate / 100
        )
      ) + 
      geom_tile()
    
  } else if (outcome == "death") {
    
    b %>% 
        ggplot(
          aes(
            x = predict1,
          y = predict2,
            fill = death_rate / 100
          )
        ) + 
        geom_tile()
  }
}

# Function for bar graphs showing outcome rate by levels of predictor
outcome_vs_predictor = function(predict, outcome){
  
  b = one_var_summarize({{predict}})
  
  if (outcome == "vax") {
      ggplot(
        data = b,
        aes(
          x = predict,
          y = vax_rate,
          fill = predict
        )
      ) + 
      geom_bar(stat = "identity")
  } else if (outcome == "hosp"){
    ggplot(
        data = b,
        aes(
          x = predict,
          y = hosp_rate / 100,
          fill = predict
        )
      ) + 
      geom_bar(stat = "identity")
  } else if (outcome == "death"){
    ggplot(
        data = b,
        aes(
          x = predict,
          y = death_rate / 100,
          fill = predict
        )
      ) + 
      geom_bar(stat = "identity")
  }
}

# Function for borough comparisons by levels of predictor
# Works for categorical or continuous predictors
borough_cat_comparisons = function(predict, outcome) {
  
  b = one_var_borough_summarize({{predict}})
      
    if (outcome == "vax") {
      
      compare = b %>% 
        pivot_longer(
          cols = num_people:num_death,
          names_to = "type",
          values_to = "count"
        ) %>% 
        filter(type %in% c("num_people", "num_vax")) %>%
        ggplot(
          aes(x = type,
              y = count,
              fill = predict
          )
        ) + 
        geom_bar(stat = "identity", position = "fill") + 
        facet_wrap(.~borough) + 
        theme(legend.position = "none") + 
        labs(
          x = "",
          y = "Proportion in Borough"
        ) + 
        scale_y_continuous(labels = scales::percent_format()) + 
        scale_x_discrete(labels = c("num_people" = "Overall", "num_vax" = "Vaccinated"))
      
    stack = b %>% 
      ggplot(aes(
        x = borough,
        y = num_vax,
        fill = predict
      )
      ) + 
      geom_bar(stat = "identity") + 
      theme(legend.position = "none") + 
        labs(
          x = "Borough",
          y = "Number of People Vaccinated"
        )
      
      vary1 = b %>% 
      ggplot(aes(x = borough, y = vax_rate)) + 
      geom_point(aes(color = predict)) + 
        labs(
          x = "Borough",
          y = "% Vaccinated"
        )
      
      total = (stack + compare) / vary1
      
      total + plot_annotation(
  title = "Outcomes Across Boroughs",
  subtitle = "Categorized by Predictor Level" 
)
  } else if (outcome == "hosp"){
      
      compare = b %>% 
        pivot_longer(
          cols = num_people:num_death,
          names_to = "type",
          values_to = "count"
        ) %>% 
        filter(type %in% c("num_people", "num_hosp")) %>%
        ggplot(
          aes(x = type,
              y = count,
              fill = predict
          )
        ) + 
        geom_bar(stat = "identity", position = "fill") + 
        facet_wrap(.~borough) + 
        theme(legend.position = "none") + 
        labs(
          x = "",
          y = "Proportion in Borough"
        ) + 
        scale_y_continuous(labels = scales::percent_format()) + 
        scale_x_discrete(labels = c("num_people" = "Overall", "num_hosp" = "Hospitalized"))
      
    stack = b %>%
      ggplot(aes(
        x = borough,
        y = num_hosp,
        fill = predict
      )
      ) + 
      geom_bar(stat = "identity") + 
      theme(legend.position = "none") + 
        labs(
          x = "Borough",
          y = "Number of People Hospitalized"
        )
      
      vary1 = b %>%
      ggplot(aes(x = borough, y = hosp_rate / 100)) + 
      geom_point(aes(color = predict)) + 
        labs(
          x = "Borough",
          y = "% Hospitalized"
        )
      
      total = (stack + compare) / vary1
      
      total + plot_annotation(
  title = "Outcomes Across Boroughs",
  subtitle = "Categorized by Predictor Level" 
)
  } else if (outcome == "death"){
 
      compare = b %>% 
        pivot_longer(
          cols = num_people:num_death,
          names_to = "type",
          values_to = "count"
        ) %>% 
        filter(type %in% c("num_people", "num_death")) %>%
        ggplot(
          aes(x = type,
              y = count,
              fill = predict
          )
        ) + 
        geom_bar(stat = "identity", position = "fill") + 
        facet_wrap(.~borough) + 
        theme(legend.position = "none") + 
        labs(
          x = "",
          y = "Proportion in Borough"
        ) + 
        scale_y_continuous(labels = scales::percent_format()) + 
        scale_x_discrete(labels = c("num_people" = "Overall", "num_deceased" = "Deceased"))
      
    stack = b %>%
      ggplot(aes(
        x = borough,
        y = num_death,
        fill = predict
      )
      ) + 
      geom_bar(stat = "identity") + 
      theme(legend.position = "none") + 
        labs(
          x = "Borough",
          y = "Number of People Deceased"
        )
      
      vary1 = b %>%
      ggplot(aes(x = borough, y = death_rate / 100)) + 
      geom_point(aes(color = predict)) + 
        labs(
          x = "Borough",
          y = "% Deceased"
        )
      
      total = (stack + compare) / vary1
      total + plot_annotation(
  title = "Outcomes Across Boroughs",
  subtitle = "Categorized by Predictor Level" 
)
  } 
}
```

### Overview of Outcome Variables

Ultimately, we ended the data cleaning process with two data sets at different levels of aggregation: one at the census interview level, and another at the PUMA level. Most of our exploratory analysis focused on evaluating predictors and outcomes by PUMA, although the interview-level data was still helpful for us to determine outcome disparities across predictors city-wide.

We began by seeking a better understanding of how each of our three key outcomes – hospitalization rate, death rate, and vaccination rate – differ by PUMA. When PUMAs are ranked from lowest outcome rate to highest outcome rate, and colored by borough, we find the following:
* Hospitalization rate ranges from nearly 4% to nearly 20%, with the plurality of high hospitalization rates occurring in Queens PUMAs and the plurality of low hospitalization rates occurring in Manhattan and Brooklyn PUMAs
* Death rate ranges from <1% to over 6%, with the plurality of high death rates occurring in Queens PUMAs and the plurality of low death rates occurring in Manhattan and Brooklyn PUMAs
* Vaccination rate ranges from nearly X% to over 100% (due to migrations between PUMAs), with all of the highest vaccination rates occurring in Manhattan and Queens, and all of the lowest vaccination rates occurring in Brooklyn and the Bronx

```{r outcomes all PUMAs, echo = FALSE, message = FALSE, warning = FALSE}

# Hospitalization rates across PUMAs, colored by borough
PUMA_hosp = puma_level_data %>% 
  ggplot(aes(x = fct_reorder(puma, covid_hosp_rate), y = covid_hosp_rate)) + 
  geom_point(aes(color = borough)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  labs(
    x = "PUMA",
    y = "% Hospitalized"
  )

# Death rates across PUMAs, colored by borough
PUMA_death = puma_level_data %>% 
  ggplot(aes(x = fct_reorder(puma, covid_death_rate), y = covid_death_rate)) + 
  geom_point(aes(color = borough)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  labs(
    x = "PUMA",
    y = "% Deceased"
  )

# Vax rates across PUMAs, colored by borough
PUMA_vax = puma_level_data %>% 
  ggplot(aes(x = fct_reorder(puma, covid_vax_rate), y = covid_vax_rate)) + 
  geom_point(aes(color = borough)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  labs(
    x = "PUMA",
    y = "% Vaccinated"
  )

puma_outcomes = (PUMA_hosp + PUMA_death) / PUMA_vax

puma_outcomes + plot_annotation(
  title = "Outcomes Across PUMAs",
  subtitle = "Categorized by Borough" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")

```

``` {r worst PUMA outcomes, echo = FALSE, message = FALSE, warning = FALSE}

# Set colors for each borough
boroughColors = setNames(c("#fde725", "#440154", "#21918c", "#3b528b", "#5ec962"), levels(puma_level_data$borough)) 

# PUMAs with highest hosp rates
PUMA_hosp_highest10 = puma_level_data %>% 
  arrange(desc(covid_hosp_rate)) %>% 
  mutate(
    rank = rank(desc(covid_hosp_rate))
  ) %>% 
  filter(rank < 11) %>% 
  ggplot(aes(x = fct_reorder(puma, desc(covid_hosp_rate)), y = covid_hosp_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) + 
  labs(
    x = "PUMA",
    y = "% Hospitalized (highest)"
  ) + 
  scale_fill_manual(values = boroughColors)

# PUMAs with highest death rates
PUMA_death_highest10 = puma_level_data %>% 
  arrange(desc(covid_death_rate)) %>% 
  mutate(
    rank = rank(desc(covid_death_rate))
  ) %>% 
  filter(rank < 11) %>% 
  ggplot(aes(x = fct_reorder(puma, desc(covid_death_rate)), y = covid_death_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) + 
  labs(
    x = "PUMA",
    y = "% Deceased (highest)"
  ) + 
  scale_fill_manual(values = boroughColors)

# PUMAs with lowest vax rates
PUMA_vax_lowest10 = puma_level_data %>% 
  arrange(covid_vax_rate) %>% 
  mutate(
    rank = rank(covid_vax_rate)
  ) %>% 
  filter(rank < 11) %>% 
  ggplot(aes(x = fct_reorder(puma, covid_vax_rate), y = covid_vax_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) + 
  labs(
    x = "PUMA",
    y = "% Vaccinated (lowest)"
  ) + 
  scale_fill_manual(values = boroughColors)

# "Worst" PUMAs
worst_pumas = (PUMA_hosp_highest10 + PUMA_death_highest10) / PUMA_vax_lowest10

worst_pumas + plot_annotation(
  title = "Worst PUMAs for Each COVID Outcome",
  subtitle = "Categorized by Borough" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

``` {r best PUMA outcomes, echo = FALSE, message = FALSE, warning = FALSE}
# PUMAs with lowest hosp rates
PUMA_hosp_lowest10 = puma_level_data %>% 
  arrange(covid_hosp_rate) %>% 
  mutate(
    rank = rank(desc(covid_hosp_rate))
  ) %>% 
  filter(rank > 44) %>% 
  ggplot(aes(x = fct_reorder(puma, covid_hosp_rate), y = covid_hosp_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) +
  labs(
    x = "PUMA",
    y = "% Hospitalized (lowest)"
  ) +
  scale_fill_manual(values = boroughColors)

# PUMAs with lowest death rates
PUMA_death_lowest10 = puma_level_data %>% 
  arrange(covid_death_rate) %>% 
  mutate(
    rank = rank(desc(covid_death_rate))
  ) %>% 
  filter(rank > 44) %>% 
  ggplot(aes(x = fct_reorder(puma, covid_death_rate), y = covid_death_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) + 
  labs(
    x = "PUMA",
    y = "% Deceased (lowest)"
  ) +
  scale_fill_manual(values = boroughColors)

# PUMAs with highest vax rates
PUMA_vax_highest10 = puma_level_data %>% 
  arrange(desc(covid_vax_rate)) %>% 
  mutate(
    rank = rank(desc(covid_vax_rate))
  ) %>% 
  filter(rank < 11) %>% 
  ggplot(aes(x = fct_reorder(puma, desc(covid_vax_rate)), y = covid_vax_rate)) + 
  geom_bar(stat = "identity", aes(fill = borough)) + 
  labs(
    x = "PUMA",
    y = "% Vaccinated (highest)"
  ) +
  scale_fill_manual(values = boroughColors)

# "Best" PUMAs
best_pumas = (PUMA_hosp_lowest10 + PUMA_death_lowest10) / PUMA_vax_highest10

best_pumas + plot_annotation(
  title = "Best PUMAs for Each COVID Outcome",
  subtitle = "Categorized by Borough" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

```{r outcomes sorted by puma, echo = FALSE, message = FALSE, warning = FALSE}

outcome.labs = c("Hospitalized", "Deceased", "Vaccinated")
names(outcome.labs) = c("covid_hosp_rate", "covid_death_rate", "covid_vax_rate")

# Hospitalizations, deaths, and ratio between the two across PUMAs, colored by borough
hosps_and_deaths_PUMA = PUMA_outcomes %>% 
  filter(!name %in% c("covid_vax_rate", "covid_ratio")) %>%
  group_by(borough) %>% 
  ggplot(
    aes(
      x = puma,
      y = outcome_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  facet_grid(name ~ ., labeller = labeller(name = outcome.labs)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  labs(
    x = "PUMA",
    y = "% With Outcome"
  )

# Vaccinations across PUMAs, colored by borough
# Separate from prior graph because different scale
vax_PUMA = PUMA_outcomes %>% 
  filter(name == "covid_vax_rate") %>% 
  group_by(borough) %>% 
  ggplot(
    aes(
      x = puma,
      y = outcome_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  facet_grid(name ~ ., labeller = labeller(name = outcome.labs)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  labs(
    x = "PUMA",
    y = "% With Outcome"
  )


outcomes_pumas_ordered = hosps_and_deaths_PUMA / vax_PUMA

outcomes_pumas_ordered + plot_annotation(
  title = "Key Outcomes Across PUMAs",
  subtitle = "Ordered by Borough" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

Although our regression modeling explores the relationship between particular variable pairings more fully to check for collinearity, we also were interested in observing how associated our key outcome variables were, and found that hospitalization and death rate were significantly correlated, whereas vaccination had limited correlation with both hospitalization (0.187) and death (0.075) at the PUMA level. Interestingly, the correlation between our key outcome variables was effectively modified by borough; for example, vaccination and hospitalization were significantly correlated in the Bronx (0.930), whereas hospitalization and death were not significantly correlated in Staten Island (0.526).

```{r key outcome associations, echo = FALSE, message = FALSE, warning = FALSE}

# Note: lines of best fit now weighted by number of people in PUMA

# Hospitalizations and deaths
hosp_vs_death = puma_level_data %>% 
  ggplot(aes(x = covid_hosp_rate, y = covid_death_rate)) + 
  geom_point(aes(color = borough, size = total_people)) + 
  geom_smooth(method = lm, se = FALSE, color = "red", aes(weight = total_people)) + 
  labs(
    x = "% Hospitalized",
    y = "% Deceased",
    size = "# of People",
    col = "Borough"
  )

# Hospitalizations and vaccinations
hosp_vs_vax = puma_level_data %>% 
  ggplot(aes(x = covid_hosp_rate, y = covid_vax_rate)) + 
  geom_point(aes(color = borough, size = total_people)) + 
  geom_smooth(method = lm, se = FALSE, color = "red", aes(weight = total_people)) + 
  labs(
    x = "% Hospitalized",
    y = "% Vaccinated",
    size = "# of People",
    col = "Borough"
  )

# Deaths and vaccinations
death_vs_vax = puma_level_data %>%
  ggplot(aes(x = covid_death_rate, y = covid_vax_rate)) + 
  geom_point(aes(color = borough, size = total_people)) + 
  geom_smooth(method = lm, se = FALSE, color = "red", aes(weight = total_people)) + 
  labs(
    x = "% Deceased",
    y = "% Vaccinated",
    size = "# of People",
    col = "Borough"
  )

outcome_associations = hosp_vs_death + hosp_vs_vax + death_vs_vax

outcome_associations + plot_annotation(
  title = "Associations Between Outcomes",
  subtitle = "Across PUMAs" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

```{r outcome correlations, echo = FALSE, message = FALSE, warning = FALSE}

# ggpairs correlations between key pairs, not faceted by borough
puma_level_data %>% 
  select(covid_hosp_rate, covid_death_rate, covid_vax_rate) %>% 
  mutate(
    covid_hosp_rate = covid_hosp_rate,
    covid_death_rate = covid_death_rate
  ) %>% 
  rename(
    "Hospitalized" = covid_hosp_rate,
    "Deceased" = covid_death_rate,
    "Vaccinated" = covid_vax_rate
  ) %>% 
  ggpairs(
    title = "Correlations Between Key Outcomes"
  ) + 
  scale_fill_discrete()

# ggpairs correlations between key pairs, faceted by borough
puma_level_data %>% 
  select(covid_hosp_rate, covid_death_rate, covid_vax_rate, borough) %>% 
  mutate(
    covid_hosp_rate = covid_hosp_rate,
    covid_death_rate = covid_death_rate
  ) %>% 
  rename(
    "Hospitalized" = covid_hosp_rate,
    "Deceased" = covid_death_rate,
    "Vaccinated" = covid_vax_rate,
    "Borough" = borough
  ) %>% 
  ggpairs(
    title = "Correlations Between Key Outcomes By Borough",
    ggplot2::aes(color = Borough, alpha = 0.3)
  ) + 
  scale_fill_discrete()
```

### Outcomes by Borough

After exploring outcomes at the PUMA level, we were keen to dive more deeply into disparities by borough. Beyond simply confirming with boxplots the distribution of key outcomes across PUMAs in a given borough (e.g. hospitalization and death distributed towards higher rates in Queens and Bronx PUMAs, vaccination distributed towards higher rates in Queens and Manhattan), we were also curious to see what would happen if we took the median city-wide PUMA for each outcome, and binarily divided the PUMAs in each borough into those above the city-wide median and those below it. Although we’re working with only 55 PUMAs, which makes our borough percentages highly sensitive to any given PUMA given small sample size, we find – to take one example, that ~79% of PUMAs in Queens are above the city-wide median PUMA on death rate, but ~86% of PUMAs in Queens are above the city-wide median PUMA on vaccination rate.

```{r hospitalizations by borough, echo = FALSE, message = FALSE, warning = FALSE}
# Outcomes distribution by borough

# Hospitalizations across PUMAs in each borough
hosps_box = puma_level_data %>% 
  ggplot(aes(x = reorder(borough, covid_hosp_rate, FUN = "median"), y = covid_hosp_rate)) + 
  geom_boxplot(aes(fill = borough), alpha = 0.3) + 
  labs(
    x = "Borough",
    y = "% Hospitalized"
  ) + 
  scale_fill_manual(values = boroughColors) + 
  theme(legend.position = "none") + 
  geom_hline(aes(yintercept=median(covid_hosp_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(0, median(covid_hosp_rate), label = "PUMA Median"), vjust = -0.5, hjust = 0, color = "red")  + 
  scale_fill_manual(values = boroughColors)

# Hospitalizations density plot by borough
hosps_density = PUMA_outcomes %>%
  filter(name == "covid_hosp_rate") %>% 
  ggplot(
    aes(
      x = outcome_rate
    )
  ) + 
  geom_density(aes(fill = reorder(borough, outcome_rate, FUN = "median")), alpha = 0.15) + 
  labs(
    x = "% Hospitalized",
    y = "Density"
  ) +
  geom_vline(aes(xintercept=median(outcome_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(median(outcome_rate), 4, label = "PUMA Median"), hjust = 1.1, color = "red")  + 
  scale_fill_manual(values = boroughColors)

hosp_by_borough = hosps_box + hosps_density

hosp_by_borough + plot_annotation(
  title = "Hospitalization By Borough",
  subtitle = "Across PUMAs" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect") + 
  labs(fill = "Borough")
```

```{r deaths by borough, echo = FALSE, message = FALSE, warning = FALSE}
# Deaths across PUMAs in each borough
deaths_box = puma_level_data %>% 
  ggplot(aes(x = reorder(borough, covid_death_rate, FUN = "median"), y = covid_death_rate)) + 
  geom_boxplot(aes(fill = borough), alpha = 0.3) + 
  labs(
    x = "Borough",
    y = "% Deceased"
  ) + 
  scale_fill_manual(values = boroughColors) + 
  theme(legend.position = "none") + 
  geom_hline(aes(yintercept=median(covid_death_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(0, median(covid_death_rate), label = "PUMA Median"), vjust = -0.5, hjust = 0, color = "red")  + 
  scale_fill_manual(values = boroughColors)

# Deaths density plot by borough
deaths_density = PUMA_outcomes %>%
  filter(name == "covid_death_rate") %>% 
  ggplot(
    aes(
      x = outcome_rate
    )
  ) + 
  geom_density(aes(fill = reorder(borough, outcome_rate, FUN = "median")), alpha = 0.15) + 
  labs(
    x = "% Deceased",
    y = "Density"
  ) +
  geom_vline(aes(xintercept=median(outcome_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(median(outcome_rate), 4, label = "PUMA Median"), hjust = -0.1, vjust = -35, color = "red")  + 
  scale_fill_manual(values = boroughColors)

deaths_by_borough = deaths_box + deaths_density

deaths_by_borough + plot_annotation(
  title = "Death Outcomes By Borough",
  subtitle = "Across PUMAs" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect") + 
  labs(fill = "Borough")
```

```{r vax by borough, echo = FALSE, message = FALSE, warning = FALSE}
# Vax across PUMAs in each borough
vax_box = puma_level_data %>% 
  ggplot(aes(x = reorder(borough, covid_vax_rate, FUN = "median"), y = covid_vax_rate)) + 
  geom_boxplot(aes(fill = borough), alpha = 0.3) + 
  labs(
    x = "Borough",
    y = "% Vaccinated"
  ) + 
  scale_fill_manual(values = boroughColors) + 
  theme(legend.position = "none") + 
  geom_hline(aes(yintercept=median(covid_vax_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(0, median(covid_vax_rate), label = "PUMA Median"), vjust = -0.5, hjust = 0, color = "red")  + 
  scale_fill_manual(values = boroughColors)

# Vax density plot by borough
vax_density = PUMA_outcomes %>%
  filter(name == "covid_vax_rate") %>% 
  ggplot(
    aes(
      x = outcome_rate
    )
  ) + 
  geom_density(aes(fill = reorder(borough, outcome_rate, FUN = "median")), alpha = 0.15) + 
  labs(
    x = "% Vaccinated",
    y = "Density"
  ) +
  geom_vline(aes(xintercept=median(outcome_rate)),
            color="red", linetype="dashed") + 
  geom_text(aes(median(outcome_rate), 4, label = "PUMA Median"), hjust = 0, vjust = 0, color = "red")  + 
  scale_fill_manual(values = boroughColors) + 
  ylim(0, 0.1)

vax_by_borough = vax_box + vax_density

vax_by_borough + plot_annotation(
  title = "Vaccination Outcomes By Borough",
  subtitle = "Across PUMAs" 
) + 
  theme(legend.position = "bottom") + 
  plot_layout(guides = "collect") + 
  labs(fill = "Borough")
```

```{r puma above/below table, echo = FALSE, message = FALSE, warning = FALSE}
# Table showing PUMAs in each borough above or below citywide median on outcome
puma_level_data %>% 
  select(puma, borough, total_people, covid_hosp_rate, above_hosp_median, covid_death_rate, above_death_median, covid_vax_rate, above_vax_median) %>%
  group_by(borough) %>% 
  summarize(
    pumas = n(),
    percent_above_hosp = sum(as.numeric(above_hosp_median == 1)) * 100 / pumas,
    percent_above_death = sum(as.numeric(above_death_median == 1)) * 100 / pumas,
    percent_above_vax = sum(as.numeric(above_vax_median == 1)) * 100 / pumas
  ) %>% 
  knitr::kable(
    digits = 1,
    caption = "% of PUMAs in Each Borough Above Citywide PUMA Median",
    col.names = c("Borough", "Total PUMAs", "% Above Hosp Median", "% Above Death Median", "% Above Vax Median")
  )
```

### Outcomes by Demographic Combinations

For each unique combination of age group, race, and sex, we wanted to determine which demographic category performed best and worst on each key outcome, and populated the following tables:

```{r outcomes by demographic combos}
# Lowest hospitalization rates
race_age_sex %>% 
  filter(outcome == "hosp_rate") %>% 
  mutate(
    outcome_rate = outcome_rate / 100
  ) %>% 
  arrange(outcome_rate) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()

# Highest hospitalization rates
race_age_sex %>% 
  filter(outcome == "hosp_rate") %>% 
  mutate(
    outcome_rate = outcome_rate / 100
  ) %>% 
  arrange(desc(outcome_rate)) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()

# Lowest death rates
race_age_sex %>% 
  filter(outcome == "death_rate") %>% 
  mutate(
    outcome_rate = outcome_rate / 100
  ) %>% 
  arrange(outcome_rate) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()

# Highest death rates
race_age_sex %>% 
  filter(outcome == "death_rate") %>% 
  mutate(
    outcome_rate = outcome_rate / 100
  ) %>% 
  arrange(desc(outcome_rate)) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()

# Lowest vax rates
race_age_sex %>% 
  filter(outcome == "vax_rate") %>% 
  mutate(
    outcome_rate = outcome_rate
  ) %>% 
  arrange(outcome_rate) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()

# Highest vax rates
race_age_sex %>% 
  filter(outcome == "vax_rate") %>% 
  mutate(
    outcome_rate = outcome_rate
  ) %>% 
  arrange(desc(outcome_rate)) %>% 
  select(race, age_class, sex, outcome, outcome_rate) %>% 
  head() %>% 
  knitr::kable()
```

Overall, hospitalization and death rates were lowest (best) among white males and females under age 30, whereas vaccination rates were highest (best) among Asian and Pacific Islander males and females. Older American Indian individuals, along with younger and middle-aged Black individuals, tended to have the lowest vaccination rates, while mixed race, American Indian, and “other” racial groups tended to have higher hospitalization and death rates.

### Associations Between Individual Predictors and Outcomes

After exploring disparities in key outcomes across PUMAs and boroughs, we turn towards our large set of predictors, and begin by trying to determine which predictors to focus on using a correlation matrix (with outcomes). In the plot below, we include text only on those tiles that are highly significant, with p < 0.01.

```{r correlations predictors vs outcomes, echo = FALSE, message = FALSE, warning = FALSE}
# Show text only for correlations with p < 0.01
puma_level_data %>% 
  select(-puma, -borough, -above_hosp_median, -above_death_median, -above_vax_median, -above_ratio_median, -total_people, -covid_ratio) %>% 
  cor_mat() %>% 
  cor_gather() %>% 
  filter(var1 %in% c("covid_hosp_rate", "covid_death_rate", "covid_vax_rate")) %>% 
  filter(!var2 %in% c("covid_hosp_rate", "covid_death_rate", "covid_vax_rate")) %>% 
  mutate(
    sig_p = ifelse(p < 0.01, T, F),
    p_if_sig = ifelse(p < 0.01, p, NA),
    r_if_sig = ifelse(p < 0.01, cor, NA)
  ) %>% 
  ggplot(aes(
    x = var1, 
    y = var2, 
    fill = cor,
    label = round(r_if_sig, 2))) + 
  geom_tile(color = "white") +  
  scale_x_discrete(
    labels = c("% Deceased", "% Hospitalized", "% Vaccinated")
  ) + 
  geom_text(
    color = "white",
    size = 4
  ) + 
  labs(
    x = "Outcome Variable",
    y = "Predictor Variable",
    title = "Correlation Matrix Between Predictors and Outcomes",
    subtitle = "At the PUMA level",
    fill = "Correlation"
  )
```

Interestingly, we find:
* The variables highly positively correlated with hospitalization rate at the PUMA level are percent US citizens and percent foreign born; the variables highly negatively correlated with hospitalization rate at the PUMA level are percent white, percent using public transit to get to work, percent with health insurance, percent English-speaking at home, percent with college education, percent with broadband access, and median personal and household incomes.
* The variables highly positively correlated with death rate at the PUMA level, are percent US citizens and percent foreign born; the variables highly negatively correlated with death rate at the PUMA level are percent using public transit to get to work, percent with health insurance, percent college educated, and median personal and household incomes.
* The variables highly positively correlated with vaccination rate at the PUMA level are percent white, percent male, percent college educated, percent with broadband access, median age, and median personal and household incomes; the variables highly negatively correlated with vaccination rate at the PUMA level are percent on welfare, percent unemployed, percent below the poverty threshold, and percent on food stamps

All in all, there are a couple of interesting trends observed in this correlation matrix. First, income seems strongly associated with all three outcome variables. In addition, the variables strongly associated with hospitalization rate also tend to be strongly associated with death rate, which is not much of a surprise given the high correlation already observed between hospitalization and death rate across PUMAs. Finally, we note that many signifiers of socioeconomic status – including poverty level, welfare, unemployment, and food stamp utilization –  seem highly correlated with vaccination, but not with hospitalization and death. Given that vaccination is a more “active” outcome (requiring deliberate action) here than hospitalization or death, which are both the result of (in all likelihood) “passive” or indeliberate transmission, the association of socioeconomic factors with vaccination begin to indicate the potential impact from significant structural inequalities at play, hindering healthcare access among the poor.

We then selected each of the four variables with highest correlation (positive or negative) to each predictor, excluding obvious redundancies (like personal income and household income), and explored specific association trends between predictor and outcome, colored by borough.

```{r PUMA hospitalization rate vs predictor, echo = FALSE, message = FALSE, warning = FALSE}
# Scatter plots across PUMAS, predictor vs outcome

# Income vs hosp
hosp_income = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = median_household_income,
      y = covid_hosp_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 100000, label.y = 1.5) + 
  labs(
    x = "Median Household Income ($)",
    y = "% Hospitalized"
  ) 

# College vs hosp
hosp_college = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_college,
      y = covid_hosp_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 50, label.y = 1.5) + 
  labs(
    x = "% with College Education",
    y = "% Hospitalized"
  ) 

# Insurance vs hosp
hosp_insurance = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_insured,
      y = covid_hosp_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 50, label.y = 1.5) + 
  labs(
    x = "% with Health Insurance",
    y = "% Hospitalized"
  ) 

# Foreign born vs hosp
hosp_foreign = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_foreign_born,
      y = covid_hosp_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 40, label.y = 1.6) + 
  labs(
    x = "% Born Outside the US",
    y = "% Hospitalized"
  ) 

hosp_predict_panel = (hosp_income + hosp_college) / (hosp_insurance + hosp_foreign)

hosp_predict_panel + 
  plot_annotation(
    title = "Association Between % Hospitalized and Given Predictors",
    subtitle = "Across PUMAs") + 
  theme(
    legend.position = "bottom"
  ) + 
  plot_layout(guides = "collect")
```

```{r PUMA death rate vs predictor, echo = FALSE, message = FALSE, warning = FALSE}

# Income vs Death
death_income = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = median_personal_income,
      y = covid_death_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 45000, label.y = 1.25) + 
  labs(
    x = "Median Personal Income ($)",
    y = "% Deceased"
  ) 

# College vs death
death_college = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_college,
      y = covid_death_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 60, label.y = 1.25) + 
  labs(
    x = "% with College Education",
    y = "% Deceased"
  ) 

# Citizenship vs death
death_citizenship = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_citizen,
      y = covid_death_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 28, label.y = 1.25) + 
  labs(
    x = "% with US Citizenship",
    y = "% Deceased"
  ) 

# Foreign born vs hosp
death_foreign = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_foreign_born,
      y = covid_death_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 45, label.y = 1.25) + 
  labs(
    x = "% Born Outside the US",
    y = "% Deceased"
  ) 

death_predict_panel = (death_income + death_college) / (death_citizenship + death_foreign)

death_predict_panel + 
  plot_annotation(
    title = "Association Between % Deceased and Given Predictors",
    subtitle = "Across PUMAs") + 
  theme(
    legend.position = "bottom"
  ) + 
  plot_layout(guides = "collect")
```

```{r PUMA vax rate vs predictor, echo = FALSE, message = FALSE, warning = FALSE}

# Welfare vs vax
vax_welfare = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_welfare,
      y = covid_vax_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 60, label.y = 90) + 
  labs(
    x = "% on Welfare",
    y = "% Vaccinated"
  ) + 
  xlim(0, 100)

# Foodstamps vs vax
vax_foodstamps = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_foodstamps,
      y = covid_vax_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 30, label.y = 90) + 
  labs(
    x = "% on Food Stamps",
    y = "% Vaccinated"
  ) 

# Income vs vax
vax_income = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = median_personal_income,
      y = covid_vax_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 45000, label.y = 90) + 
  labs(
    x = "Median Personal Income ($)",
    y = "% Vaccinated"
  ) 

# Unemployment vs vax
vax_unemployment = 
  puma_level_data %>% 
  ggplot(
    aes(
      x = perc_unemployed,
      y = covid_vax_rate
    )
  ) + 
  geom_point(aes(color = borough)) + 
  geom_smooth(se = FALSE, method = "lm", color = "red", aes(weight = total_people)) + 
  stat_cor(method = "pearson", label.x = 3, label.y = 90) + 
  labs(
    x = "% Unemployed",
    y = "% Vaccinated"
  ) 

vax_predict_panel = (vax_welfare + vax_foodstamps) / (vax_income + vax_unemployment)

vax_predict_panel + 
  plot_annotation(
    title = "Association Between % Vaccinated and Given Predictors",
    subtitle = "Across PUMAs") + 
  theme(
    legend.position = "bottom"
  ) + 
  plot_layout(guides = "collect")
```

Beyond the predictors significantly associated with each outcome, we wanted to focus as well on how outcomes varied by levels of key socioeconomic variables – namely, race, age group, and sex. Because we lack individual outcome data (i.e. each census observation within a given PUMA has the same PUMA-level hospitalization, death, and vaccination rate), we assumed for this analysis that all persons in a given PUMA had equal likelihood of a particular outcome (hospitalization, death, or vaccination) being true, with the likelihood corresponding to the PUMA outcome rate.

```{r hospitalization rate by demo, echo = FALSE, message = FALSE, warning = FALSE}
# Demographics 

# Hospitalizations vs race
first_predict = outcome_vs_predictor(race, "hosp") + 
  labs(
    x = "Race",
    y = "% Hospitalized",
    title = "% Hospitalized by Race Category",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

# Hospitalizations vs age
# First create data frame for use later
age_grouped = interview_level_data %>% 
  mutate(
    weighted_vax = perwt * puma_vacc_rate,
    weighted_hosp = perwt * puma_hosp_rate,
    weighted_death = perwt * puma_death_rate,
    age = as.factor(cut(age, breaks = c(0, 15, 30, 45, 60, 75, 90, 105), include.lowest = TRUE))) %>% 
  group_by(age) %>% 
  mutate(age = fct_recode(age, 
                          "<16" = "[0,15]", 
                          "16-30" = "(15,30]", 
                          "31-45" = "(30,45]", 
                          "46-60" = "(45,60]", 
                          "61-75" = "(60,75]", 
                          "76-90" = "(75,90]", 
                          "91-105" = "(90,105]")) %>% 
  summarize(
    vax_rate = sum(weighted_vax) / sum(perwt),
    hosp_rate = sum(weighted_hosp) / sum(perwt),
    death_rate = sum(weighted_death) / sum(perwt),
    people = sum(perwt),
    num_vaxxed = sum(weighted_vax) / 100,
    num_hosp = sum(weighted_hosp) / 100,
    num_dead = sum(weighted_death) / 100
  )

# Plot hospitalization rates
second_predict = age_grouped %>% 
  ggplot(
    aes(
      x = age,
      y = hosp_rate / 100,
      fill = age
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Age Group",
    y = "% Hospitalized",
    title = "% Hospitalized by Age Group",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")
  
# Hospitalizations vs sex
third_predict = outcome_vs_predictor(sex, "hosp") + 
  labs(
    x = "Sex",
    y = "% Hospitalized",
    title = "% Hospitalized by Sex",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

first_predict + second_predict + third_predict
```

```{r death rate by demo, echo = FALSE, message = FALSE, warning = FALSE}
# Deaths vs race
first_predict = outcome_vs_predictor(race, "death") + 
  labs(
    x = "Race",
    y = "% Deceased",
    title = "% Deceased by Race Category",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

# Deaths vs age
second_predict = age_grouped %>% 
  ggplot(
    aes(
      x = age,
      y = death_rate / 100,
      fill = age
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Age Group",
    y = "% Deceased",
    title = "% Deceased by Age Group",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")
  
# Deaths vs sex
third_predict = outcome_vs_predictor(sex, "death") + 
  labs(
    x = "Sex",
    y = "% Deceased",
    title = "% Deceased by Sex",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

first_predict + second_predict + third_predict
```

```{r vax rate by demo, echo = FALSE, message = FALSE, warning = FALSE}
# Vax vs race
first_predict = outcome_vs_predictor(race, "vax") + 
  labs(
    x = "Race",
    y = "% Vaccinated",
    title = "% Vaccinated by Race Category",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

# Vax vs age
second_predict = age_grouped %>% 
  ggplot(
    aes(
      x = age,
      y = vax_rate,
      fill = age
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Age Group",
    y = "% Vaccinated",
    title = "% Vaccinated by Age Group",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")
  
# Vax vs sex
third_predict = outcome_vs_predictor(sex, "vax") + 
  labs(
    x = "Sex",
    y = "% Vaccinated",
    title = "% Vaccinated by Sex",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

first_predict + second_predict + third_predict
```

Some key findings include:
* Males and females appear similar on each outcome
* Hospitalization and death rates tend to be higher after middle age compared to those below middle age, whereas vaccination rate shows a general increase with each age group
* In general, white individuals have a lower likelihood of hospitalization and death, but a higher likelihood – along with Asian and Pacific Islanders – of vaccination, whereas other groups of color and Native Americans seem to have higher hospitalization and death rates, but lower vaccination rates

Similarly, we examined how key outcomes varied across categories of a few seemingly important predictor variables for each outcome observed in our correlation matrix:

```{r hosp rate by ses, echo = FALSE, message = FALSE, warning = FALSE}
# Socioeconomics

# Hospitalizations vs Income
# First create data frame for use later
income_grouped = interview_level_data %>% 
  mutate(
    weighted_vax = perwt * puma_vacc_rate,
    weighted_hosp = perwt * puma_hosp_rate,
    weighted_death = perwt * puma_death_rate,
    household_income = as.factor(cut(household_income, breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000), include.lowest = TRUE))) %>% 
    mutate(household_income = fct_recode(household_income, 
                                         "<$50k" = "[0,5e+04]", 
                                         "+$50k-100k" = "(5e+04,1e+05]", 
                                         "+$100k-150k" = "(1e+05,1.5e+05]", 
                                         "+$150k-200k" = "(1.5e+05,2e+05]", 
                                         "+$200k-250k" = "(2e+05,2.5e+05]", 
                                         "+$250k-300k" = "(2.5e+05,3e+05]", 
                                         "+$300k-350k" = "(3e+05,3.5e+05]",
                                         ">$350k" = "(3.5e+05,4e+05]")) %>% 
  group_by(household_income) %>% 
  summarize(
    vax_rate = sum(weighted_vax) / sum(perwt),
    hosp_rate = sum(weighted_hosp) / sum(perwt),
    death_rate = sum(weighted_death) / sum(perwt),
    people = sum(perwt),
    num_vaxxed = sum(weighted_vax) / 100,
    num_hosp = sum(weighted_hosp) / 100,
    num_dead = sum(weighted_death) / 100
  ) %>% 
  drop_na(household_income)

# Plot hospitalization rates
first_predict_ses = income_grouped %>% 
  ggplot(
    aes(
      x = household_income,
      y = hosp_rate / 100,
      fill = household_income
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Household Income ($)",
    y = "% Hospitalized",
    title = "% Hospitalized by Household Income",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

# Hospitalizations vs Education
second_predict_ses = outcome_vs_predictor(education, "hosp") + 
  labs(
    x = "Education",
    y = "% Hospitalized",
    title = "% Hospitalized by Education Status",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

# Hospitalizations vs Insurance
third_predict_ses = outcome_vs_predictor(health_insurance, "hosp") + 
  labs(
    x = "Health Insurance",
    y = "% Hospitalized",
    title = "% Hospitalized by Health Insurance Type",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

# Hospitalizations vs Birthplace
fourth_predict_ses = outcome_vs_predictor(birthplace, "hosp") + 
  labs(
    x = "Birthplace",
    y = "% Hospitalized",
    title = "% Hospitalized by Birthplace",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(hosp_rate / 100, 2)), vjust = 1.5, color = "white")

(first_predict_ses + second_predict_ses) / (third_predict_ses + fourth_predict_ses)
```

```{r death rate by ses, echo = FALSE, message = FALSE, warning = FALSE}

# Deaths vs Income
first_predict_ses = income_grouped %>% 
  ggplot(
    aes(
      x = household_income,
      y = death_rate / 100,
      fill = household_income
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Household Income ($)",
    y = "% Deceased",
    title = "% Deceased by Household Income",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

# Deaths vs Education
second_predict_ses = outcome_vs_predictor(education, "death") + 
  labs(
    x = "Education",
    y = "% Deceased",
    title = "% Deceased by Education Status",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

# Deaths vs Citizenship
third_predict_ses = outcome_vs_predictor(US_citizen, "death") + 
  labs(
    x = "Citizenship Status",
    y = "% Deceased",
    title = "% Deceased by Health Insurance Type",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

# Deaths vs Birthplace
fourth_predict_ses = outcome_vs_predictor(birthplace, "death") + 
  labs(
    x = "Birthplace",
    y = "% Deceased",
    title = "% Deceased by Birthplace",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(death_rate / 100, 2)), vjust = 1.5, color = "white")

(first_predict_ses + second_predict_ses) / (third_predict_ses + fourth_predict_ses)
```

```{r vax rate by ses, echo = FALSE, message = FALSE, warning = FALSE}

# Vax vs Welfare
first_predict_ses = outcome_vs_predictor(on_welfare, "vax") + 
  labs(
    x = "On Welfare",
    y = "% Vaccinated",
    title = "% Vaccinated by Welfare Status",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

# Vax vs Foodstamps
second_predict_ses = outcome_vs_predictor(on_foodstamps, "vax") + 
  labs(
    x = "On Food Stamps",
    y = "% Vaccinated",
    title = "% Vaccinated by Food Stamp Status",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None") + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

# Vax vs Income
third_predict_ses = income_grouped %>% 
  ggplot(
    aes(
      x = household_income,
      y = vax_rate,
      fill = household_income
    )
  ) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Household Income ($)",
    y = "% Vaccinated",
    title = "% Vaccinated by Household Income",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

# Vax vs Employment
fourth_predict_ses = outcome_vs_predictor(employment, "vax") + 
  labs(
    x = "Employment Status",
    y = "% Vaccinated",
    title = "% Vaccinated by Employment Status",
    subtitle = "Across All Census Interviews",
    caption = "Note: Assumes PUMA-wide outcome rate applies to all individuals in PUMA"
  ) + 
  theme(legend.position = "None",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0)) + 
  geom_text(aes(label = round(vax_rate, 2)), vjust = 1.5, color = "white")

(first_predict_ses + second_predict_ses) / (third_predict_ses + fourth_predict_ses)
```

Again, there were a few interesting findings here, such as:
* We observe a monotonic decrease in hospitalization and death rate as household income increases, but a monotonic increase in vaccination rate as household income increases as well
* Individuals with public health insurance tend to perform similarly on key outcomes to those with no health insurance at all, with both groups worse than those who have private health insurance
* Individuals with college and graduate education tend to perform better on key outcomes than those without any college education
* Those with unknown citizenship status, which may signify being “undocumented,” tend to have lower death rates – perhaps indicative of underreporting due to fear of immigration control / policing, i.e. attention on the person or family
* As already noted, those on welfare and foodstamps, as well as unemployed, are significantly less likely to be vaccinated against COVID-19

### Associations Between Predictors and Outcomes by Borough

To build on the work above, we wanted to observe disparities within boroughs, knowing that different boroughs have different demographic compositions and that the ideal visualizations would allow us to understand how outcomes vary conditioned on borough demographic composition. Each of the following visualizations has three panels: number of people with outcome, categorized by borough and colored by predictor level; % of people with outcome in each borough, colored by predictor level, compared to the overall composition of the borough by predictor level; and percent with outcome variable, in each borough, plotted by level of predictor.

```{r hospitalization borough disparities, echo = FALSE, message = FALSE, warning = FALSE}

# Hospitalizations by race
borough_cat_comparisons(race, "hosp") + plot_annotation(
  title = "Hospitalizations Across Boroughs",
  subtitle = "Categorized by Race" 
)

# Hospitalizations by sex
borough_cat_comparisons(sex, "hosp") + plot_annotation(
  title = "Hospitalizations Across Boroughs",
  subtitle = "Categorized by Sex" 
)

# Hospitalizations by age
borough_cat_comparisons(age_class, "hosp")  + plot_annotation(
  title = "Hospitalizations Across Boroughs",
  subtitle = "Categorized by Age Group" 
)
```

```{r death borough disparities, echo = FALSE, message = FALSE, warning = FALSE}

# Deaths by race
borough_cat_comparisons(race, "death") + plot_annotation(
  title = "Deaths Across Boroughs",
  subtitle = "Categorized by Race" 
)

# Deaths by sex
borough_cat_comparisons(sex, "death") + plot_annotation(
  title = "Deaths Across Boroughs",
  subtitle = "Categorized by Sex" 
)

# Deaths by age
borough_cat_comparisons(age_class, "death")  + plot_annotation(
  title = "Deaths Across Boroughs",
  subtitle = "Categorized by Age Group" 
)
```

```{r vax borough disparities, echo = FALSE, message = FALSE, warning = FALSE}

# Vax by race
borough_cat_comparisons(race, "vax")  + plot_annotation(
  title = "Vaccinations Across Boroughs",
  subtitle = "Categorized by Race" 
)

# Vax by sex
borough_cat_comparisons(sex, "vax")  + plot_annotation(
  title = "Vaccinations Across Boroughs",
  subtitle = "Categorized by Sex" 
)

# Vax by age
borough_cat_comparisons(age_class, "vax") + plot_annotation(
  title = "Vaccinations Across Boroughs",
  subtitle = "Categorized by Age Group" 
)
```

The most interesting finding here is that Manhattan seems to have the most significant racial disparities on hospitalization rate and death rate, along with age disparities on hospitalization rate, and racial and age disparities in vaccination rate. In general, the level of inequality on key outcomes across demographics in Manhattan tends to be higher than in other boroughs.

Another set of data visualizations that shows how different outcome rates vary within boroughs across levels of a key demographic predictor (age group, sex, race) is included below.

```{r borough predictor heatmap hosp, echo = FALSE, message = FALSE, warning = FALSE}
# Hospitalizations
# Race x Borough
race_hosp_borough = heatmap_two_var(race, borough, "hosp") + 
  labs(
    x = "Race",
    y = "Borough",
    title = "% Hospitalized by Borough and Race",
    fill = "% Hospitalized"
  ) + 
  theme(legend.position = "none",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0))

# Sex x Borough
sex_hosp_borough = heatmap_two_var(sex, borough, "hosp") + 
  labs(
    x = "Sex",
    y = "Borough",
    title = "% Hospitalized by Borough and Sex",
    fill = "% Hospitalized"
  ) + 
  theme(legend.position = "none")

# Age x Borough
age_hosp_borough = heatmap_two_var(age_class, borough, "hosp") + 
  labs(
    x = "Age Group",
    y = "Borough",
    title = "% Hospitalized by Borough and Age Group",
    fill = "% Hospitalized"
  ) + 
  theme(legend.position = "none")

hosp_heat = race_hosp_borough / sex_hosp_borough / age_hosp_borough

hosp_heat + theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

```{r borough predictor heatmap death, echo = FALSE, message = FALSE, warning = FALSE}
# Deaths
# Race x Borough
race_death_borough = heatmap_two_var(race, borough, "death") + 
  labs(
    x = "Race",
    y = "Borough",
    title = "% Deceased by Borough and Race",
    fill = "% Deceased"
  ) + 
  theme(legend.position = "none",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0))

# Sex x Borough
sex_death_borough = heatmap_two_var(sex, borough, "death") + 
  labs(
    x = "Sex",
    y = "Borough",
    title = "% Deceased by Borough and Sex",
    fill = "% Deceased"
  ) + 
  theme(legend.position = "none")

# Age x Borough
age_death_borough = heatmap_two_var(age_class, borough, "death") + 
  labs(
    x = "Age Group",
    y = "Borough",
    title = "% Deceased by Borough and Age Group",
    fill = "% Deceased"
  ) + 
  theme(legend.position = "none")

death_heat = race_death_borough / sex_death_borough / age_death_borough

death_heat + theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

```{r borough predictor heatmap vax, echo = FALSE, message = FALSE, warning = FALSE}
# Vaccinations
# Race x Borough
race_vax_borough = heatmap_two_var(race, borough, "vax") + 
  labs(
    x = "Race",
    y = "Borough",
    title = "% Vaccinated by Borough and Race",
    fill = "% Vaccinated"
  ) + 
  theme(legend.position = "none",
        axis.text.x = element_text(angle = -60, vjust = 0.5, hjust = 0))

# Sex x Borough
sex_vax_borough = heatmap_two_var(sex, borough, "vax") + 
  labs(
    x = "Sex",
    y = "Borough",
    title = "% Vaccinated by Borough and Sex",
    fill = "% Vaccinated"
  ) + 
  theme(legend.position = "none")

# Age x Borough
age_vax_borough = heatmap_two_var(age_class, borough, "vax") + 
  labs(
    x = "Age Group",
    y = "Borough",
    title = "% Vaccinated by Borough and Age Group",
    fill = "% Vaccinated"
  ) + 
  theme(legend.position = "none")

vax_heat = race_vax_borough / sex_vax_borough / age_vax_borough

vax_heat + theme(legend.position = "bottom") + 
  plot_layout(guides = "collect")
```

## Regression

TO DO!

## Predictive Risk Scoring & Clustering

Following our regression work, we decided to make our insights more actionable by developing a novel scoring method capable of indicating whether a PUMA is at relatively lower or higher risk of achieving some COVID-19-related outcome. To demonstrate the method, we developed a risk score for whether a PUMA is likely to have achieved or not achieved a vaccination rate of 70% among residents, corresponding to the level of population immunity generally considered requisite to “halt the pandemic.” That said, our method is applicable to other outcomes as well, and one might imagine using it to score a given PUMA on the possibility of a hospitalization rate above X%, or a death rate above Y%. We only chose to begin with vaccination rate given our inability to develop a linear regression for this particular outcome, as opposed to hospitalization and death rates.

The risk scoring method we developed is predicated on (regularized, lasso) logistic regression, used most often for classification tasks because predictions can be interpreted as class probabilities. Regularization further prevents overfitting of the model. After defining our outcome as 1 for below 70% vaccination and 0 for equal to or above 70% vaccination, we converted our set of predictors to matrix form, and then trained a glmnet model on our training data using 5-fold cross-validation repeated 100 times given the large number of predictors compared to our mere 55 PUMA samples, and because we were interested in predicting the risk score of vaccination rate for each PUMA in our data set. Through our lasso regression, we found an optimal lambda tuning parameter of 0.0102, and generated a model prediction accuracy of 0.886 (~87%). Generally, however, obtaining the kappa value averaged over the simulated confusion matrices is a more useful metric for prediction given unbalanced classes (of our 55 PUMAs, 41 achieve vaccination rate >= 70%, and only 14 do not); Our optimal model’s averaged kappa was 0.63, which is considered reasonably decent, but again suggests that the limited number of in-sample data points may result in model overfitting. 


